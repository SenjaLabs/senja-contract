// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import {Script, console} from "forge-std/Script.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import {Helper} from "./Helper.sol";

interface IMintBurnUSDT {
    function mint(address to, uint256 amount) external;
    function burn(uint256 amount) external;
    function burnFrom(address from, uint256 amount) external;
}

contract MintToken is Script, Helper {
    // ***** FILL THIS IN *****
    address public TOKEN;
    // ************************

    function setUp() public {
        // vm.createSelectFork(vm.rpcUrl("base_mainnet"));
        // vm.createSelectFork(vm.rpcUrl("kaia_mainnet"));
        // optimism
        // hyperliquid
    }

    function _getUtils() internal {
        if (block.chainid == 8453) {
            TOKEN = BASE_USDT;
        } else if (block.chainid == 8217) {
            TOKEN = KAIA_USDT;
        }
    }

    function run() public {
        _getUtils();
        vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
        console.log("balance before mint: ", IERC20(TOKEN).balanceOf(vm.envAddress("PUBLIC_KEY")));
        IMintBurnUSDT(TOKEN).mint(vm.envAddress("PUBLIC_KEY"), 10_100 * 10 ** IERC20Metadata(TOKEN).decimals());

        // burn
        // IERC20(TOKEN).approve(vm.envAddress("PUBLIC_KEY"), 1_100 * 10 ** IERC20Metadata(TOKEN).decimals());
        // IMintBurnUSDT(TOKEN).burnFrom(vm.envAddress("PUBLIC_KEY"), 1_100 * 10 ** IERC20Metadata(TOKEN).decimals());

        // balance after mint
        console.log("balance after mint: ", IERC20(TOKEN).balanceOf(vm.envAddress("PUBLIC_KEY")));
        vm.stopBroadcast();
    }
}

// RUN
// forge script MintToken --broadcast -vvv
