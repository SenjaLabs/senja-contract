// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import {Test, console} from "forge-std/Test.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {LendingPool} from "../src/LendingPool.sol";
import {Position} from "../src/Position.sol";
import {LendingPoolRouter} from "../src/LendingPoolRouter.sol";
import {LendingPoolFactory} from "../src/LendingPoolFactory.sol";
import {LendingPoolDeployer} from "../src/LendingPoolDeployer.sol";
import {IsHealthy} from "../src/IsHealthy.sol";
import {Protocol} from "../src/Protocol.sol";
import {IOrakl} from "../src/interfaces/IOrakl.sol";

contract DragonSwapTest is Test {
    address public owner = makeAddr("owner");
    address public bob = makeAddr("bob");
    address public alice = makeAddr("alice");

    address public swapRouter = 0xA324880f884036E3d21a09B90269E1aC57c7EC8a;
    address public priceFeed = 0xE5EAed32b3ABC15657d703d4996D830b7A064DA4; // WKAIA/USDT price feed
    LendingPoolFactory public lendingPoolFactory;
    LendingPoolDeployer public lendingPoolDeployer;
    IsHealthy public isHealthy;
    Protocol public protocol;

    address public USDT = 0xd077A400968890Eacc75cdc901F0356c943e4fDb;
    address public WKAIA = 0x19Aac5f612f524B754CA7e7c41cbFa2E981A4432;

    LendingPool public lendingPool;

    function setUp() public {
        vm.createSelectFork(vm.rpcUrl("kaia_mainnet"));
        
        // Setup token balances for testing
        deal(USDT, owner, 100_000e6);
        deal(USDT, bob, 50_000e6);
        deal(USDT, alice, 30_000e6);
        deal(WKAIA, owner, 100 ether);
        deal(WKAIA, bob, 50 ether);
        deal(WKAIA, alice, 30 ether);
        
        vm.deal(owner, 100 ether);
        vm.deal(bob, 50 ether);
        vm.deal(alice, 30 ether);
        
        // Deploy required contracts for factory
        isHealthy = new IsHealthy();
        lendingPoolDeployer = new LendingPoolDeployer();
        protocol = new Protocol();
        
        // Deploy LendingPoolFactory
        lendingPoolFactory = new LendingPoolFactory(address(isHealthy), address(lendingPoolDeployer), address(protocol));
        
        // Set the factory in the deployer
        lendingPoolDeployer.setFactory(address(lendingPoolFactory));
        
        // Create lending pool using factory - WKAIA as collateral, USDT as borrow token
        address lendingPoolAddress = lendingPoolFactory.createLendingPool(WKAIA, USDT, 8e17);
        lendingPool = LendingPool(payable(lendingPoolAddress));
    }

    // RUN
    // forge test --match-test test_swap -vvv
    function test_swap() public {
        vm.startPrank(bob);
        
        console.log("=== Test: Supply 10 WKAIA, Swap 1 WKAIA to USDT ===");
        console.log("Bob's initial WKAIA balance:", IERC20(WKAIA).balanceOf(bob));
        console.log("Bob's initial USDT balance:", IERC20(USDT).balanceOf(bob));
        
        // Supply 10 WKAIA as collateral
        console.log("--- Supplying 10 WKAIA as collateral ---");
        IERC20(WKAIA).approve(address(lendingPool), 10 ether);
        lendingPool.supplyCollateral(10 ether, bob);
        
        // Get position address
        address router = lendingPool.router();
        address payable positionAddress = payable(LendingPoolRouter(router).addressPositions(bob));
        console.log("Bob's position address:", positionAddress);
        console.log("Position WKAIA balance after supply:", IERC20(WKAIA).balanceOf(positionAddress));
        
        console.log("------ check balance before swap");
        console.log(
            "balance of position wkaia before swap", IERC20(address(WKAIA)).balanceOf(positionAddress)
        );
        console.log(
            "balance of position usdt before swap", IERC20(address(USDT)).balanceOf(positionAddress)
        );
        console.log("-----");
        
        // Get real price from Orakl price feed
        console.log("------ getting real price from Orakl");
        IOrakl priceFeedContract = IOrakl(priceFeed);
        (uint80 roundId, int256 price, uint256 updatedAt) = priceFeedContract.latestRoundData();
        uint256 wkaiaPrice = uint256(price);
        uint8 decimals = priceFeedContract.decimals();
        
        console.log("WKAIA/USDT price from Orakl:", wkaiaPrice);
        console.log("Price feed decimals:", decimals);
        console.log("Price last updated:", updatedAt);
        console.log("Round ID:", roundId);
        
        
        // Calculate expected amount and slippage info
        console.log("------ calculating swap parameters");
        uint256 expectedAmount = (1 ether * 157) / (1000 * 1e12); // 0.157 USDT per WKAIA
        uint256 slippageTolerance = 100; // 5% slippage
        uint256 minAmount = expectedAmount * (10000 - slippageTolerance) / 10000;
        
        console.log("Expected USDT amount:", expectedAmount);
        console.log("Slippage tolerance:", slippageTolerance, "basis points (1%)");
        console.log("Minimum USDT amount:", minAmount);
        
        // Swap 1 WKAIA to USDT (directly from Position contract)
        console.log("------ swapping 1 WKAIA to USDT");
        Position(positionAddress).swapTokenByPosition(WKAIA, USDT, 1 ether, 100); // 1% slippage tolerance
        
        console.log("------ after swap");
        console.log(
            "balance of position wkaia after swap", IERC20(address(WKAIA)).balanceOf(positionAddress)
        );
        console.log(
            "balance of position usdt after swap", IERC20(address(USDT)).balanceOf(positionAddress)
        );
        console.log("-----");
        
        // Get actual USDT received
        uint256 actualUSDT = IERC20(USDT).balanceOf(positionAddress);
        console.log("Actual USDT received from swap:", actualUSDT);
        
        // Calculate slippage percentage
        uint256 slippagePercent = ((expectedAmount - actualUSDT) * 10000) / expectedAmount;
        console.log("Actual slippage:", slippagePercent, "basis points");
        console.log("Expected vs Actual:", expectedAmount, "vs", actualUSDT);
        
        // Verify the swap worked correctly
        assertEq(IERC20(WKAIA).balanceOf(positionAddress), 9 ether, "WKAIA balance should be 9 ether");
        
        vm.stopPrank();
    }
}